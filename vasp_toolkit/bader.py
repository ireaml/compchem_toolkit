"""
Class to parse ACF files generated by the Bader code.

Adapted from pymatgen (https://pymatgen.org/pymatgen.command_line.bader_caller.html)
to avoid parsing the CHGCAR file.
"""

from pymatgen.core.structure import Structure
from pymatgen.io.vasp.outputs import Potcar
from pymatgen.io.vasp.inputs import Poscar

class Bader:
    """
    Bader analysis from ACF.dat and VASP outputs.
    Adapted from pymatgen, to avoid parsing the CHGCAR files.

    .. attribute: data
        Atomic data parsed from bader analysis. Essentially a list of dicts
        of the form::
        [
            {
                "atomic_vol": 8.769,
                "min_dist": 0.8753,
                "charge": 7.4168,
                "y": 1.1598,
                "x": 0.0079,
                "z": 0.8348
            },
            ...
        ]
    .. attribute: vacuum_volume
        Vacuum volume of the Bader analysis.
    .. attribute: vacuum_charge
        Vacuum charge of the Bader analysis.
    .. attribute: nelectrons
        Number of electrons of the Bader analysis.
    .. attribute: chgcar
        Chgcar object associated with input CHGCAR file.
    .. attribute: atomic_densities
        list of charge densities for each atom centered on the atom
        excess 0's are removed from the array to reduce the size of the array
        the charge densities are dicts with the charge density map,
        the shift vector applied to move the data to the center, and the original dimension of the charge density map
        charge:
            {
            "data": charge density array
            "shift": shift used to center the atomic charge density
            "dim": dimension of the original charge density map
            }
    """
    def __init__(
        self,
        output_path: str="./",
        acf_filename: str="ACF.dat",
        potcar_filename: str="POTCAR",
        poscar_filename: str="POSCAR",
    ):
        """
        Initializes the Bader caller.

        Args:
            output_path (str): Path to the top-level directory containing the files to parse.
            acf_filename (str): The filename of the ACF file.
            potcar_filename (str): The filename of the POTCAR.
            poscar_filename (str): The filename of the POSCAR.
        """
        data = []
        if not acf_filename:
            acf_filename = "ACF.dat"

        self.potcar = Potcar.from_file(f"{output_path}/{potcar_filename}") if potcar_filename is not None else None
        self.poscar = Poscar.from_file(f"{output_path}/{poscar_filename}", read_velocities=False)
        self.natoms = self.poscar.natoms
        self.structure = Structure.from_file(f"{output_path}/{poscar_filename}")

        # List of nelects for each atom from potcar
        potcar_indices = []
        for i, v in enumerate(self.natoms):
            potcar_indices += [i] * v
        self.nelects = (
            [self.potcar[potcar_indices[i]].nelectrons for i in range(len(self.structure))] if self.potcar else []
        )

        with open(f"{output_path}/{acf_filename}") as f:
            raw = f.readlines()
            headers = ("x", "y", "z", "charge", "min_dist", "atomic_vol")
            raw.pop(0)
            raw.pop(0)
            while True:
                l = raw.pop(0).strip()
                if l.startswith("-"):
                    break
                vals = map(float, l.split()[1:])
                data.append(dict(zip(headers, vals)))
            for l in raw:
                toks = l.strip().split(":")
                if toks[0] == "VACUUM CHARGE":
                    self.vacuum_charge = float(toks[1])
                elif toks[0] == "VACUUM VOLUME":
                    self.vacuum_volume = float(toks[1])
                elif toks[0] == "NUMBER OF ELECTRONS":
                    self.nelectrons = float(toks[1])
        self.data = data

    def get_charge(self, atom_index):
        """
        Convenience method to get the charge on a particular atom. This is the "raw"
        charge generated by the Bader program, not a partial atomic charge. If the cube file
        is a spin-density file, then this will return the spin density per atom with
        positive being spin up and negative being spin down.
        Args:
            atom_index:
                Index of atom.
        Returns:
            Charge associated with atom from the Bader analysis.
        """
        return self.data[atom_index]["charge"]

    def get_charge_transfer(self, atom_index, nelect=None):
        """
        Returns the charge transferred for a particular atom. A positive value means
        that the site has gained electron density (i.e. exhibits anionic character)
        whereas a negative value means the site has lost electron density (i.e. exhibits
        cationic character). If the arg nelect is not supplied, then POTCAR must be
        supplied to determine nelect.
        Args:
            atom_index:
                Index of atom.
            nelect:
                number of electrons associated with an isolated atom at this index.
                For most DFT codes this corresponds to the number of valence electrons
                associated with the pseudopotential (e.g. ZVAL for VASP).
        Returns:
            Charge transfer associated with atom from the Bader analysis.
            Given by bader charge on atom - nelect for associated atom.
        """
        if not self.nelects and nelect is None:
            raise ValueError("No NELECT info! Need POTCAR for VASP or nelect argument for cube file")
        return self.data[atom_index]["charge"] - (nelect if nelect is not None else self.nelects[atom_index])

    def get_partial_charge(self, atom_index, nelect=None):
        """
        Convenience method to get the partial charge on a particular atom. This is
        simply the negative value of the charge transferred. A positive value indicates
        that the atom has cationic character, whereas a negative value indicates the
        site has anionic character.
        Args:
            atom_index:
                Index of atom.
            nelect:
                number of electrons associated with an isolated atom at this index.
                For most DFT codes this corresponds to the number of valence electrons
                associated with the pseudopotential (e.g. ZVAL for VASP).
        Returns:
            Charge associated with atom from the Bader analysis.
        """
        return -self.get_charge_transfer(atom_index, nelect)

    def get_charge_decorated_structure(self):
        """
        Returns a charge decorated structure
        Note, this assumes that the Bader analysis was correctly performed on a file
        with electron densities
        """
        charges = [-self.get_charge(i) for i in range(len(self.structure))]
        struc = self.structure.copy()
        struc.add_site_property("charge", charges)
        return struc